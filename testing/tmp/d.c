// fact15.schml should return #(struct:Int) generated by the schml compiler.

//This is the boiler plate
#include <stdio.h>
#include <stdlib.h>

void* alloc_ptr;

//These are the declarations
long interp_cast_code35( long interp_cast_clos34 ,long val11 ,long type113 ,long type214 ,long label15 );
long cast_fn2_code41( long cast_fn2_clos40 ,long f4 ,long t15 ,long t26 ,long lbl7 );
long annon_code37( long annon_clos36 ,long v9 ,long v8 );
long annon_code39( long annon_clos38 );
long fact_code43( long fact_clos42 ,long f2 ,long n1 );

//Obviously this is the main function
int main( ){
long interp_cast10;
long prog_returns23;
long cast_fn23;
long fact0;
long tmp_clos44;
long tmp25;
long tmp26;
long tmp24;
interp_cast10 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 2), alloc_ptr);
((long*)interp_cast10)[0] = ((long)interp_cast_code35);
((long*)interp_cast10)[1] = 0;
prog_returns23 = (cast_fn23 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr), (((long*)cast_fn23)[3] = interp_cast10, ((long*)cast_fn23)[2] = cast_fn23, ((long*)cast_fn23)[0] = ((long)cast_fn2_code41), ((long*)cast_fn23)[1] = 0, (fact0 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr), (((long*)fact0)[3] = interp_cast10, ((long*)fact0)[2] = cast_fn23, ((long*)fact0)[0] = ((long)fact_code43), ((long*)fact0)[1] = cast_fn23, (((long (*)(long,long,long))((long*)fact0)[0])(fact0,(tmp_clos44 = ((long*)fact0)[1], (((long (*)(long,long,long,long,long))((long*)tmp_clos44)[0])(tmp_clos44,fact0,(tmp25 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr), (((long*)tmp25)[0] = 2, ((long*)tmp25)[1] = 15, ((long*)tmp25)[2] = (tmp26 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr), (((long*)tmp26)[0] = 2, ((long*)tmp26)[1] = 15, ((long*)tmp26)[2] = 7, ((long*)tmp26)[3] = 15, tmp26)), ((long*)tmp25)[3] = 15, tmp25)),(tmp24 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr), (((long*)tmp24)[0] = 2, ((long*)tmp24)[1] = 15, ((long*)tmp24)[2] = 7, ((long*)tmp24)[3] = 15, tmp24)),"Implicit cast in application at fact15.schml::159 on expression at fact15.schml::165"))),15))))));
printf("Int : %d\n", (void *)prog_returns23);
return 0;
}


//Here are all the definitions for Subroutines
long interp_cast_code35( long interp_cast_clos34 ,long val11 ,long type113 ,long type214 ,long label15 ){
long tag16;
long type117;
long tag118;
long dyn_box28;
long tag219;
long value20;
long tmp_clos32;
long tag121;
long dyn_box29;
long tag222;
long tmp_clos33;
if (type113 == 7){
if (7 == type214){
return val11;
} else {
tag16 = (val11 & 7);
if (1 == tag16){
if (15 == type214){
return (val11 >> 3);
} else {
if (7 == type214){
return (((val11 >> 3) << 3) + 1);
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
if (7 == tag16){
if (23 == type214){
return (val11 >> 3);
} else {
if (7 == type214){
return (((val11 >> 3) << 3) + 7);
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
if (0 == tag16){
type117 = ((long*)val11)[1];
tag118 = (type117 & 7);
if (0 == tag118){
if (7 == type214){
dyn_box28 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 2), alloc_ptr);
((long*)dyn_box28)[0] = ((long*)val11)[0];
((long*)dyn_box28)[1] = type117;
return dyn_box28;
} else {
tag219 = (type214 & 7);
if (tag219 == 0){
value20 = ((long*)val11)[0];
tmp_clos32 = ((long*)value20)[1];
return (((long (*)(long,long,long,long,long))((long*)tmp_clos32)[0])(tmp_clos32,value20,type117,type214,label15));
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
if (type117 == 15){
if (15 == type214){
return ((long*)val11)[0];
} else {
if (7 == type214){
return ((((long*)val11)[0] << 3) + 1);
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
if (type117 == 23){
if (23 == type214){
return ((long*)val11)[0];
} else {
if (7 == type214){
return ((((long*)val11)[0] << 3) + 7);
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
}
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
}
}
} else {
tag121 = (type113 & 7);
if (0 == tag121){
if (7 == type214){
dyn_box29 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 2), alloc_ptr);
((long*)dyn_box29)[0] = val11;
((long*)dyn_box29)[1] = type113;
return dyn_box29;
} else {
tag222 = (type214 & 7);
if (tag222 == 0){
tmp_clos33 = ((long*)val11)[1];
return (((long (*)(long,long,long,long,long))((long*)tmp_clos33)[0])(tmp_clos33,val11,type113,type214,label15));
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
if (type113 == 15){
if (15 == type214){
return val11;
} else {
if (7 == type214){
return ((val11 << 3) + 1);
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
if (type113 == 23){
if (23 == type214){
return val11;
} else {
if (7 == type214){
return ((val11 << 3) + 7);
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
} else {
puts(((const char*) label15));
exit(-1);
return 0;
}
}
}
}
}

long cast_fn2_code41( long cast_fn2_clos40 ,long f4 ,long t15 ,long t26 ,long lbl7 ){
long annon30;
long annon31;
if (((long*)t15)[0] == ((long*)t26)[0]){
annon30 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 8), alloc_ptr);
((long*)annon30)[7] = f4;
((long*)annon30)[6] = t26;
((long*)annon30)[5] = t15;
((long*)annon30)[4] = lbl7;
((long*)annon30)[3] = ((long*)cast_fn2_clos40)[3];
((long*)annon30)[2] = ((long*)cast_fn2_clos40)[2];
((long*)annon30)[0] = ((long)annon_code37);
((long*)annon30)[1] = ((long*)cast_fn2_clos40)[2];
return annon30;
} else {
annon31 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr);
((long*)annon31)[3] = lbl7;
((long*)annon31)[2] = ((long*)cast_fn2_clos40)[2];
((long*)annon31)[0] = ((long)annon_code39);
((long*)annon31)[1] = ((long*)cast_fn2_clos40)[2];
return annon31;
}
}

long annon_code37( long annon_clos36 ,long v9 ,long v8 ){
return (((long (*)(long,long,long,long,long))((long*)((long*)annon_clos36)[3])[0])(((long*)annon_clos36)[3],(((long (*)(long,long,long))((long*)((long*)annon_clos36)[7])[0])(((long*)annon_clos36)[7],(((long (*)(long,long,long,long,long))((long*)((long*)annon_clos36)[3])[0])(((long*)annon_clos36)[3],v9,((long*)((long*)annon_clos36)[6])[2],((long*)((long*)annon_clos36)[5])[2],((long*)annon_clos36)[4])),(((long (*)(long,long,long,long,long))((long*)((long*)annon_clos36)[3])[0])(((long*)annon_clos36)[3],v8,((long*)((long*)annon_clos36)[6])[3],((long*)((long*)annon_clos36)[5])[3],((long*)annon_clos36)[4])))),((long*)((long*)annon_clos36)[5])[1],((long*)((long*)annon_clos36)[6])[1],((long*)annon_clos36)[4]));
}

long annon_code39( long annon_clos38 ){
puts(((const char*) ((long*)annon_clos38)[3]));
exit(-1);
return 0;
}

long fact_code43( long fact_clos42 ,long f2 ,long n1 ){
long tmp27;
if (n1 == 0){
return 1;
} else {
return (n1 * (((long (*)(long,long,long))((long*)f2)[0])(f2,(((long (*)(long,long,long,long,long))((long*)((long*)fact_clos42)[3])[0])(((long*)fact_clos42)[3],f2,(tmp27 = (long) (posix_memalign(&alloc_ptr, 8, 8 * 4), alloc_ptr), (((long*)tmp27)[0] = 2, ((long*)tmp27)[1] = 15, ((long*)tmp27)[2] = 7, ((long*)tmp27)[3] = 15, tmp27)),7,"Implicit cast in application at fact15.schml::138 on expression at fact15.schml::141")),(n1 - 1))));
}
}

