#lang typed/racket
#|------------------------------------------------------------------------------+
|Pass: compiler/generate-c
+-------------------------------------------------------------------------------+
|Author: Andre Kuhlenshmidt (akuhlens@indiana.edu)                              |
+-------------------------------------------------------------------------------+
| Description: 
+-------------------------------------------------------------------------------+
| Grammer:
+------------------------------------------------------------------------------|#
;; The define-pass syntax
(require schml/framework/build-compiler
         schml/framework/helpers
         schml/framework/errors
	 schml/compiler/language)

;; Only the pass is provided by this module
(provide generate-c)

(: IMDT-C-TYPE String)
(define IMDT-C-TYPE "long")

(: C-EXIT String)
(define C-EXIT "exit(-1)")

(: C-INCLUDES (Listof String))
(define C-INCLUDES '("stdio.h" "stdlib.h"))


(: generate-c (-> Data2-Lang Config Void))
(define (generate-c prgm config)
  (match-let ([(Prog (list name count type) (Labels lbl* exp)) prgm])
    (call-with-output-file (Config-c-path config) #:exists 'replace #:mode 'text
      (lambda ([p : Output-Port])
       (parameterize ([current-output-port p])
         (emit-program name type lbl* exp))))))

(: emit-program (-> String Schml-Type D2-Bnd-Code* D2-Body Void))
(define (emit-program name type code* body)
  (emit-comment name type)
  (emit-boiler-plate)
  (emit-declarations code*)
  (emit-main body)
  (emit-subroutines code*))

(define (emit-comment name type)
  (printf "// ~a should return ~a generated by the schml compiler.\n" name type))

(: emit-boiler-plate (-> Void))
(define (emit-boiler-plate)
  (display "\n//This is the boiler plate\n")
  (for ([i : String C-INCLUDES])
    (display "#include <") (display i) (display ">\n"))
  (newline)
  (display "void* alloc_ptr;\n"))

(: emit-declarations (-> D2-Bnd-Code* Void))
(define (emit-declarations code*)
  (display "\n//These are the declarations\n")
  (for : Void ([bnd : D2-Bnd-Code code*])
    (match-let ([(cons lbl (Code var* exp)) bnd])
      (emit-function-prototype IMDT-C-TYPE (uid->string lbl) (map uid->string var*)) 
      (display ";\n"))))

(: emit-main (-> D2-Body Void))
(define (emit-main b)
  (display "\n//Obviously this is the main function\n")
  (emit-function "int" "main" '() b))

(: emit-subroutines (-> D2-Bnd-Code* Void))
(define (emit-subroutines code*)
    (display "\n//Here are all the definitions for Subroutines\n")
  (for : Void ([bnd : D2-Bnd-Code code*])
   (match-let ([(cons lbl (Code var* body)) bnd])
     (emit-function IMDT-C-TYPE (uid->string lbl) var* body))))

(: emit-function-prototype (-> String String (Listof String) Void))
(define (emit-function-prototype returns name vars)
  (display returns)
  (display #\space)
  (display name)
  (display-seq vars "( " (string-append IMDT-C-TYPE " ") "," " " ")"))

(: emit-function (-> String String Uid* D2-Body Void))
(define (emit-function returns name args body)
  (match-let ([(Locals local-var* tail) body])  
    (emit-function-prototype returns name (map uid->string args))
    (emit-block local-var* tail)
    (newline)
    (newline)))

(: emit-block (-> Uid* D2-Tail Void))
(define (emit-block local-var* tail)
  (let ([local-var* (map uid->string local-var*)])
    (display "{\n")
    (display-seq local-var* "" (string-append IMDT-C-TYPE " ") "" ";\n" "")
    (emit-tail tail)
    (display "}")))

(: emit-tail (-> D2-Tail Void))
(define (emit-tail tail)
  (match tail
    [(Begin s* t) (begin (for ([s : D2-Stmt s*])
                           (emit-stmt s)
                           (display ";\n"))
                         (emit-tail t))]
    [(If t c a) (begin (display "if ")
                       (emit-pred t)
                       (emit-block '() c)
                       (display " else ")
                       (emit-block '() a)
                       (newline))]
    [(Return e) (begin (display "return ")
                       (emit-expr e)
                       (display ";\n"))]))

(: emit-pred (-> D2-Pred Void))
(define (emit-pred r)
  (match r
    [(If t c a) (emit-ternary (emit-pred t) (emit-pred c) (emit-pred a))]
    [(Begin stm* pred) (emit-begin-expr stm* (emit-pred pred))]
    [(Relop p e1 e2) (emit-op p (list e1 e2))]))

(: emit-expr (-> D2-Expr Void))
(define (emit-expr e)
  (match e
    [(If t c a) (emit-ternary (emit-pred t) (emit-expr c) (emit-expr a))]
    [(Begin stm* exp) (emit-begin-expr stm* (emit-expr exp))]
    [(App exp exp*) (emit-wrap 
                     (emit-cast->fn exp exp*)
                     (sequence emit-expr exp* display "(" "" "," "" ")"))]
    [(Op p exp*)     (emit-op p exp*)]
    [(Var i)         (display (uid->string i))]
    [(Quote k)       (print k)]
    [other (if (Code-Label? other)
               (let ([lbl (Code-Label-value other)])
                 (: uid->string (-> Uid String))
                 (begin (display "((")
                        (display "long)")
                        (printf "~a~a" (Uid-prefix lbl) (Uid-suffix lbl))
                        (display ")")))
               (error 'gc-emit-expr-match))]))

(: emit-stmt (-> D2-Stmt Void))
(define (emit-stmt s)
  (match s
    [(Assign uid exp) (begin (display (uid->string uid))
                             (display " = ")
                             (emit-expr exp))]
    [(Op p exp*) (emit-op p exp*)]))

(: emit-op (-> Symbol D2-Expr* Void))
(define (emit-op p exp*)
  (match*
   (p exp*)
   [('Exit '()) (display C-EXIT)]
   [('Array-set! (list a o v)) (begin
                                 (emit-wrap (display "(long*)")
                                       (emit-expr a)) 
                                 (display "[")
                                 (emit-expr o)
                                 (display "] = ")
                                 (emit-expr v))]
   [('Array-ref (list a o)) (begin
                                 (emit-wrap (display "(long*)")
                                            (emit-expr a)) 
                                 (display "[")
                                 (emit-expr o)
                                 (display "]"))]
   [('Printf (cons fmt exp*)) (begin (display "printf")
                                     (emit-wrap
                                      (emit-expr fmt)
                                      (unless (null? exp*)
                                        (display ", ")
                                        (sequence emit-expr exp* display "" "(void *)" "," "" ""))))]
   [('Print (list exp)) (begin (display "puts") (emit-wrap (emit-cast->string (emit-expr exp))))]
   [('Alloc (list exp)) (begin (display "(long) (posix_memalign(&alloc_ptr, 8, 8 * ")
                               (emit-expr exp)
                               (display "), alloc_ptr)"))]
   [(p (list exp1 exp2))
    (emit-wrap
     (emit-expr exp1)
     (case p
       [(+ - * / >> << < <= > >=) (display #\space) (display p) (display #\space)]
       [(=) (display " == ")]
       [(binary-and) (display " & ")]
       [(binary-or)  (display " | ")])
     (emit-expr exp2))]))


;;(: emit-primitive-expr (->  Void))
(define (emit-primitive-expr p exp*) (error 'emit-primitive-expr-undefined))
(define (emit-primitive-pred p e1 e2) (error 'emit-primitive-pred-undefined))

;; primitives for generating syntax

(define-syntax-rule (emit-wrap a ...)
  (begin (display "(") a ... (display ")")))


(: display-seq (-> (Listof Any) Any Any Any Any Any Void))
(define (display-seq seq start before between after finish)
  (sequence display seq display start before between after finish))

(: sequence (All (A B) (-> (-> A Void) (Listof A) (-> B Void) B B B B B Void)))
(define (sequence f seq g start before between after finish)
  (: loop (All (A) (-> (-> A Void) (Listof A) Void)))
  (define (loop f seq)
    (if (null? seq)
        (g finish)
        (let ([seq^ (cdr seq)])
          (if (null? seq^)
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g finish))
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g between)
                     (loop f seq^))))))
  (g start)
  (loop f seq))

;; common c syntax constructs
(define-syntax-rule (emit-begin-expr stm* exp)
  (emit-wrap
   (sequence emit-stmt stm* display "" "" "" ", " "")
   exp))

(define-syntax-rule (emit-ternary a b c)
  (emit-wrap a (display " ? ") b (display " : ") c))


;; C Style casts
(define-syntax-rule (emit-cast->string exp)
  (emit-wrap (display "(const char*) ") exp))

(define-syntax-rule (emit-imdt-cast) (error 'emit-imdt-cast))

(: emit-cast->fn (-> D2-Expr D2-Expr* Void))
(define (emit-cast->fn exp args)
   (emit-wrap
    (emit-wrap
     (display IMDT-C-TYPE)
     (display " (*)")
     (let ([a* : (Listof String) (map (lambda (a) IMDT-C-TYPE) args)])
       (display-seq a* "(" "" "," "" ")")))
    (emit-expr exp)))
