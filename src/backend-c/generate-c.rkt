#lang typed/racket
#|------------------------------------------------------------------------------+
|pass: src/generate-c
+-------------------------------------------------------------------------------+
|Author: Andre Kuhlenshmidt (akuhlens@indiana.edu)                              |
+-------------------------------------------------------------------------------+
| Description:
+-------------------------------------------------------------------------------+
| Grammer:
+------------------------------------------------------------------------------|#
;; The define-pass syntax
(require "../helpers.rkt"
         "../errors.rkt"
         "../configuration.rkt"
         "../language/data5.rkt"
         "../macros.rkt")


;; Only the pass is provided by this module
(provide generate-c)

(: IMDT-C-TYPE String)
(define IMDT-C-TYPE "long")

(: C-EXIT String)
(define C-EXIT "exit(-1)")

(: C-INCLUDES (Listof String))
(define C-INCLUDES '("stdio.h" "stdlib.h" "sys/time.h"))


(: generate-c (-> Data5-Lang Config Void))
(define (generate-c prgm config)
  (match-let ([(Prog (list name count type) (GlobDecs d* (Labels lbl* exp))) prgm])
    (call-with-output-file (Config-c-path config) #:exists 'replace #:mode 'text
      (lambda ([p : Output-Port])
        (parameterize ([current-output-port p])
          (emit-program name type lbl* d* exp (Config-mem-limit config)))))))

(: emit-program (-> String Schml-Type D5-Bnd-Code* (Listof Uid) D5-Body Natural Void))
(define (emit-program name type code* d* body mem-limit)
  (emit-source-comment name type)
  (emit-boiler-plate mem-limit)
  (emit-var-declarations d*)
  (emit-declarations code*)
  (emit-main body mem-limit)
  (emit-subroutines code*))

(: init-mem (Natural -> Void))
(define (init-mem n)
  (let ([s (number->string n)])
    (display "free_ptr = (long)(posix_memalign(&alloc_ptr, 8, ")
    (display s)
    (display "), alloc_ptr);")
    (display "limit = free_ptr + ")
    (display s)
    (display ";\n")
    (display "allocd_mem = 0;\n")))

(define timer-boiler-plate
  (concat-string-literal
   "//This is the global state for the timer\n"
   "struct timeval timer_start_time;\n"
   "struct timeval timer_stop_time;\n"
   "struct timeval timer_result_time;\n"
   "int timer_started = 1;\n"
   "int timer_stopped = 1;\n\n"
   "void timer_report(){\n\n"
   "    // some very minor error checking\n"
   "    if(timer_started){\n"
   "        printf(\"error starting timer\");\n"
   "        exit(-1);\n"
   "    }\n"
   "    if(timer_stopped){\n"
   "        printf(\"error stopping timer\");\n"
   "        exit(-1);\n"
   "    }\n\n"
   "double t1 = timer_start_time.tv_sec + (timer_start_time.tv_usec / 1000000.0);\n"
   "double t2 = timer_stop_time.tv_sec + (timer_stop_time.tv_usec / 1000000.0);\n"
   "printf(\"time (sec): %lf\\n\", t2 - t1);\n"
   "}\n"
   #;(
   "    // subtract the two times in order to get result \n"
   "    timersub(&timer_stop_time, &timer_start_time, &timer_result_time);\n\n"
   "    // print out the result \n"
   "    printf(\"time (sec): %f\\n\", ((double) timer_result_time.tv_sec) +\n"
   "            (((double) timer_result_time.tv_usec) / 1000000.0));\n"
   "}\n")))


(define (emit-source-comment name type)
  (printf "// ~a should return ~a generated by the schml compiler.\n" name type))

(: emit-alloc (Natural -> Void))
(define (emit-alloc n)
  (let ([s (number->string n)])
    (display "long alloc(int n){")
  (display "    long result = free_ptr;")
  (display "    long newFree = result + n;")
  (display "    allocd_mem+=n;")
  (display "    if (newFree >= limit){")
  (display "        printf(\"Requesting more memory\\n\");")
  (display "          free_ptr = (long)(posix_memalign(&alloc_ptr, 8, ")
  (display s)
  (display "), alloc_ptr);")
  (display "          limit = free_ptr + ")
  (display s)
  (display ";")
  (display "          return alloc (n);")
  (display "    }")
  (display "    free_ptr = newFree;")
  (display "    return result;")
  (display "}")))

(: emit-boiler-plate (Natural -> Void))
(define (emit-boiler-plate n)
  (display "\n//This is the boiler plate\n")
  (for ([i : String C-INCLUDES])
    (display "#include <") (display i) (display ">\n"))
  (newline)
  (display "void* alloc_ptr;\nlong free_ptr;\nlong limit;\nunsigned long allocd_mem;\n\n")
  (emit-alloc n)
  (newline)
  (display timer-boiler-plate)
  (newline))

(: emit-var-declarations (-> (Listof Uid) Void))
(define (emit-var-declarations d*)
  (display "\n//These are the variable declarations\n")
  (display-seq (map uid->string d*) "" (string-append IMDT-C-TYPE " ") "" ";\n" ""))

(: emit-declarations (-> D5-Bnd-Code* Void))
(define (emit-declarations code*)
  (display "\n//These are the declarations\n")
  (for : Void ([bnd : D5-Bnd-Code code*])
       (match-let ([(cons lbl (Code var* exp)) bnd])
         (emit-function-prototype IMDT-C-TYPE (uid->string lbl) (map uid->string var*))
         (display ";\n"))))

(: emit-main (-> D5-Body Natural Void))
(define (emit-main b mem-limit)
  (display "\n//Obviously this is the main function\n")
  (match-let ([(Locals local-var* tail) b])
    (emit-function-prototype "int" "main" '())
    (let ([local-var* (map uid->string local-var*)])
      (display "{\n")
      (display-seq local-var* "" (string-append IMDT-C-TYPE " ") "" ";\n" "")
      (init-mem mem-limit)
      (newline)
      (emit-main-tail tail)
      (display "printf(\"%lu bytes allocated\\n\",allocd_mem);\n")
      (display "return 0;")
      (display "}"))
    (newline)
    (newline)))

(: emit-main-tail (-> D5-Tail Void))
(define (emit-main-tail tail)
  (logging emit-tail (Vomit) tail)
  (match tail
    [(Begin s* t)
     (begin (for ([s : D5-Effect s*])
              (emit-effect s)
              (display ";\n"))
            (emit-main-tail t))]
    [(If t c a)
     (begin (display "if ")
            (emit-pred t)
            (emit-block '() c)
            (display " else ")
            ;; emit-block calls emit-tail which will cause problems if
            ;; main branches around return
            (emit-block '() a)
            (newline))]
    [(Return e) (display "")]))

(: emit-subroutines (-> D5-Bnd-Code* Void))
(define (emit-subroutines code*)
  (display "\n//Here are all the definitions for Subroutines\n")
  (for : Void ([bnd : D5-Bnd-Code code*])
       (match-let ([(cons lbl (Code var* body)) bnd])
         (emit-function IMDT-C-TYPE (uid->string lbl) var* body))))

(: emit-function-prototype (-> String String (Listof String) Void))
(define (emit-function-prototype returns name vars)
  (display returns)
  (display #\space)
  (display name)
  (display-seq vars "( " (string-append IMDT-C-TYPE " ") "," " " ")"))

(: emit-function (-> String String Uid* D5-Body Void))
(define (emit-function returns name args body)
  (match-let ([(Locals local-var* tail) body])
    (emit-function-prototype returns name (map uid->string args))
    (emit-block local-var* tail)
    (newline)
    (newline)))

(: emit-block (-> Uid* D5-Tail Void))
(define (emit-block local-var* tail)
  (let ([local-var* (map uid->string local-var*)])
    (display "{\n")
    (display-seq local-var* "" (string-append IMDT-C-TYPE " ") "" ";\n" "")
    (emit-tail tail)
    (display "}")))

(: emit-tail (-> D5-Tail Void))
(define (emit-tail tail)
  (logging emit-tail (Vomit) tail)
  (match tail
    [(Begin s* t)
     (begin (for ([s : D5-Effect s*])
              (emit-effect s)
              (display ";\n"))
            (emit-tail t))]
    [(If t c a)
     (begin (display "if ")
            (emit-pred t)
            (emit-block '() c)
            (display " else ")
            (emit-block '() a)
            (newline))]
    [(Return e)
     (if (Success? e)
         (display "return 0;")
         (begin
           (display "return ")
           (emit-value e)
           (display ";\n")))]))

(: emit-pred (-> D5-Pred Void))
(define (emit-pred r)
  (match r
    #;[(If t c a) (emit-ternary (emit-pred t) (emit-pred c) (emit-pred a))]
    #;[(Begin stm* pred) (emit-begin stm* (emit-pred pred))]
    #;[(App v v*) (emit-function-call v v*)]
    [(Relop p e1 e2) (emit-op p (list e1 e2))]))

(: emit-value (-> D5-Value Void))
(define (emit-value e)
  (match e
    [(If t c a)       (emit-ternary (emit-pred t) (emit-value c) (emit-value a))]
    #;[(Begin stm* exp) (emit-begin stm* (emit-value exp))]
    [(App-Code v v*)       (emit-function-call v v*)]
    [(Op p exp*)      (emit-op p exp*)]
    [(Var i)          (display (uid->string i))]
    [(Quote k)        (print k)]
    ;; TODO Consider changing how Halt is handled
    [(Halt)           (display "exit(-1),-1")]
    [(Code-Label i)  (begin
                       (display "((")
                       (display "long)")
                       (display (uid->string i))
                       (display ")"))]
    [other   (error 'generate-c-emit-value-match)]))



(: emit-effect (-> D5-Effect Void))
(define (emit-effect s)
  (match s
    [(If t (Begin c _) (Begin a _))
     (begin (display "if")
            (emit-pred t)
            (display "{")
            (emit-begin c (void))
            (display "} else {")
            (emit-begin a (void))
            (display "}")
            (newline))]
    [(Repeat i st sp (Begin e* _))
     (begin (display "for(")
            (display (uid->string i))
            (display " = ")
            (emit-value st)
            (display " ; ")
            (display (uid->string i))
            (display " < ")
            (emit-value sp)
            (display " ; ")
            (display (uid->string i))
            (display " += 1 ) {\n")
            (emit-begin e* (display "__asm__(\"\");"))
            (display "}\n"))]
    [(Op p exp*)
     (emit-op p exp*)]
    [(Halt) (display C-EXIT)] ;; FIXME: fix that
    [(Assign uid exp)
     (begin (display (uid->string uid))
            (display " = ")
            (emit-value exp))]
    [(No-Op) (display " 0 ")]))

(: emit-op (-> Symbol D5-Value* Void))
(define (emit-op p exp*)
  (match* (p exp*)
    ;;[('Exit '()) (display C-EXIT)]
    [('Array-set! (list a o v)) (begin
                                  (emit-wrap (display "(long*)")
                                             (emit-value a))
                                  (display "[")
                                  (emit-value o)
                                  (display "] = ")
                                  (emit-value v))]
    [('Array-ref (list a o)) (begin
                               (emit-wrap (display "(long*)")
                                          (emit-value a))
                               (display "[")
                               (emit-value o)
                               (display "]"))]
    [('Printf (cons fmt exp*)) (begin (display "printf")
                                      (emit-wrap
                                       (emit-value fmt)
                                       (unless (null? exp*)
                                         (display ", ")
                                         (sequence emit-value exp* display "" "(void *)" "," "" ""))))]
    [('Print (list exp)) (begin (display "puts") (emit-wrap (emit-cast->string (emit-value exp))))]
    [('Alloc (list exp)) (begin (display "alloc(8 * ")
                                (emit-value exp)
                                (display ")"))]
    [('Exit (list exp)) (begin (display "exit") (emit-wrap (emit-value exp)))]
    [('timer-start (list))
     (display "timer_started = gettimeofday(&timer_start_time, NULL)")]
    [('timer-stop  (list))
     (display "timer_stopped = gettimeofday(&timer_stop_time, NULL)")]
    [('timer-report (list))
     (display "timer_report()")]
    [(p (list exp1 exp2))
     (emit-wrap
      (emit-value exp1)
      (case p
        [(+ - * < <= > >=) (display #\space) (display p) (display #\space)]
        [(=) (display " == ")]
        [(%>>) (display " >> ")]
        [(%<<) (display " << ")]
        [(%/) (display " / ")]
        [(binary-and) (display " & ")]
        [(binary-or)  (display " | ")]
        [(binary-xor) (display " ^ ")]
        [else (error 'backend-c-emit-op)])
      (emit-value exp2))]
    [(other wise) (error 'backend-c/generate-c/emit-op "unmatched value")]))



;;(: emit-primitive-value (->  Void))
(define (emit-primitive-value p exp*) (error 'emit-primitive-value-undefined))
(define (emit-primitive-pred p e1 e2) (error 'emit-primitive-pred-undefined))

(: emit-function-call (-> D5-Value D5-Value* Void))
(define (emit-function-call val val*)
  (emit-wrap
   (if (Code-Label? val)
       (display (uid->string (Code-Label-value val)))
       (emit-cast->fn val val*))
   (sequence emit-value val* display "(" "" "," "" ")")))

;; primitives for generating syntax
(define-syntax-rule (emit-wrap a ...)
  (begin (display "(") a ... (display ")")))

(: display-seq (-> (Listof Any) Any Any Any Any Any Void))
(define (display-seq seq start before between after finish)
  (sequence display seq display start before between after finish))

(: sequence (All (A B) (-> (-> A Void) (Listof A) (-> B Void) B B B B B Void)))
(define (sequence f seq g start before between after finish)
  (: loop (All (A) (-> (-> A Void) (Listof A) Void)))
  (define (loop f seq)
    (if (null? seq)
        (g finish)
        (let ([seq^ (cdr seq)])
          (if (null? seq^)
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g finish))
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g between)
                     (loop f seq^))))))
  (g start)
  (loop f seq))

;; common c syntax constructs
(define-syntax-rule (emit-begin s* emit-res)
  (begin
    (for ([s : D5-Effect s*])
      (emit-effect s)
      (display ";\n"))
    emit-res))

(define-syntax-rule (emit-ternary a b c)
  (emit-wrap a (display " ? ") b (display " : ") c))


;; C Style casts
(define-syntax-rule (emit-cast->string exp)
  (emit-wrap (display "(const char*) ") exp))

(define-syntax-rule (emit-imdt-cast) (error 'emit-imdt-cast))

(: emit-cast->fn (-> D5-Value D5-Value* Void))
(define (emit-cast->fn exp args)
  (emit-wrap
   (emit-wrap
    (display IMDT-C-TYPE)
    (display " (*)")
    (let ([a* : (Listof String) (map (lambda (a) IMDT-C-TYPE) args)])
      (display-seq a* "(" "" "," "" ")")))
   (emit-value exp)))
