#lang typed/racket
#|------------------------------------------------------------------------------+
|Pass: src/generate-c
+-------------------------------------------------------------------------------+
|Author: Andre Kuhlenshmidt (akuhlens@indiana.edu)                              |
+-------------------------------------------------------------------------------+
| Description:
+-------------------------------------------------------------------------------+
| Grammer:
+------------------------------------------------------------------------------|#
;; The define-pass syntax
(require schml/src/helpers
         schml/src/errors
	 schml/src/language)

;; Only the pass is provided by this module
(provide generate-c)

(: IMDT-C-TYPE String)
(define IMDT-C-TYPE "long")

(: C-EXIT String)
(define C-EXIT "exit(-1)")

(: C-INCLUDES (Listof String))
(define C-INCLUDES '("stdio.h" "stdlib.h"))


(: generate-c (-> Data2-Lang Config Void))
(define (generate-c prgm config)
  (match-let ([(Prog (list name count type) (Labels lbl* exp)) prgm])
    (call-with-output-file (Config-c-path config) #:exists 'replace #:mode 'text
      (lambda ([p : Output-Port])
       (parameterize ([current-output-port p])
         (emit-program name type lbl* exp))))))

(: emit-program (-> String Schml-Type D2-Bnd-Code* D2-Body Void))
(define (emit-program name type code* body)
  (emit-source-comment name type)
  (emit-boiler-plate)
  (emit-declarations code*)
  (emit-main body)
  (emit-subroutines code*))

(define (emit-source-comment name type)
  (printf "// ~a should return ~a generated by the schml compiler.\n" name type))

(: emit-boiler-plate (-> Void))
(define (emit-boiler-plate)
  (display "\n//This is the boiler plate\n")
  (for ([i : String C-INCLUDES])
    (display "#include <") (display i) (display ">\n"))
  (newline)
  (display "void* alloc_ptr;\n"))

(: emit-declarations (-> D2-Bnd-Code* Void))
(define (emit-declarations code*)
  (display "\n//These are the declarations\n")
  (for : Void ([bnd : D2-Bnd-Code code*])
    (match-let ([(cons lbl (Code var* exp)) bnd])
      (emit-function-prototype IMDT-C-TYPE (uid->string lbl) (map uid->string var*))
      (display ";\n"))))

(: emit-main (-> D2-Body Void))
(define (emit-main b)
  (display "\n//Obviously this is the main function\n")
  (emit-function "int" "main" '() b))

(: emit-subroutines (-> D2-Bnd-Code* Void))
(define (emit-subroutines code*)
    (display "\n//Here are all the definitions for Subroutines\n")
  (for : Void ([bnd : D2-Bnd-Code code*])
   (match-let ([(cons lbl (Code var* body)) bnd])
     (emit-function IMDT-C-TYPE (uid->string lbl) var* body))))

(: emit-function-prototype (-> String String (Listof String) Void))
(define (emit-function-prototype returns name vars)
  (display returns)
  (display #\space)
  (display name)
  (display-seq vars "( " (string-append IMDT-C-TYPE " ") "," " " ")"))

(: emit-function (-> String String Uid* D2-Body Void))
(define (emit-function returns name args body)
  (match-let ([(Locals local-var* tail) body])
    (emit-function-prototype returns name (map uid->string args))
    (emit-block local-var* tail)
    (newline)
    (newline)))

(: emit-block (-> Uid* D2-Tail Void))
(define (emit-block local-var* tail)
  (let ([local-var* (map uid->string local-var*)])
    (display "{\n")
    (display-seq local-var* "" (string-append IMDT-C-TYPE " ") "" ";\n" "")
    (emit-tail tail)
    (display "}")))

(: emit-tail (-> D2-Tail Void))
(define (emit-tail tail)
  (match tail
    [(Begin s* t) (begin (for ([s : D2-Effect s*])
                           (emit-effect s)
                           (display ";\n"))
                         (emit-tail t))]
    [(If t c a) (begin (display "if ")
                       (emit-pred t)
                       (emit-block '() c)
                       (display " else ")
                       (emit-block '() a)
                       (newline))]
    [(Return e) (begin (display "return ")
                       (emit-value e)
                       (display ";\n"))]))

(: emit-pred (-> D2-Pred Void))
(define (emit-pred r)
  (match r
    [(If t c a) (emit-ternary (emit-pred t) (emit-pred c) (emit-pred a))]
    [(Begin stm* pred) (emit-begin stm* (emit-pred pred))]
    [(App v v*) (emit-function-call v v*)]
    [(Relop p e1 e2) (emit-op p (list e1 e2))]))

(: emit-value (-> D2-Value Void))
(define (emit-value e)
  (match e
    [(If t c a)       (emit-ternary (emit-pred t) (emit-value c) (emit-value a))]
    [(Begin stm* exp) (emit-begin stm* (emit-value exp))]
    [(App v v*)       (emit-function-call v v*)]
    [(Op p exp*)      (emit-op p exp*)]
    [(Var i)          (display (uid->string i))]
    [(Quote k)        (print k)]
    [(Halt)           (display "C-EXIT")]
    [(Code-Label i)  (begin
                        (display "((")
                        (display "long)")
                        (display (uid->string i))
                        (display ")"))]
    [other   (error 'gc-emit-value-match)]))

(: emit-effect (-> D2-Effect Void))
(define (emit-effect s)
  (match s
    [(If t c a) (emit-ternary (emit-pred t) (emit-effect c) (emit-effect a))]
    [(Begin e* _) (emit-begin e* (display " 0 "))]
    [(App v v*)  (emit-function-call v v*)]
    [(Op p exp*) (emit-op p exp*)]
    [(Assign uid exp) (begin (display (uid->string uid))
                             (display " = ")
                             (emit-value exp))]
    [(No-Op)     (display " 0 ")]))

(: emit-op (-> Symbol D2-Value* Void))
(define (emit-op p exp*)
  (match* (p exp*)
   ;;[('Exit '()) (display C-EXIT)]
   [('Array-set! (list a o v)) (begin
                                 (emit-wrap (display "(long*)")
                                       (emit-value a))
                                 (display "[")
                                 (emit-value o)
                                 (display "] = ")
                                 (emit-value v))]
   [('Array-ref (list a o)) (begin
                                 (emit-wrap (display "(long*)")
                                            (emit-value a))
                                 (display "[")
                                 (emit-value o)
                                 (display "]"))]
   [('Printf (cons fmt exp*)) (begin (display "printf")
                                     (emit-wrap
                                      (emit-value fmt)
                                      (unless (null? exp*)
                                        (display ", ")
                                        (sequence emit-value exp* display "" "(void *)" "," "" ""))))]
   [('Print (list exp)) (begin (display "puts") (emit-wrap (emit-cast->string (emit-value exp))))]
   [('Alloc (list exp)) (begin (display "(long) (posix_memalign(&alloc_ptr, 8, 8 * ")
                               (emit-value exp)
                               (display "), alloc_ptr)"))]
   [('Exit (list exp)) (begin (display "exit") (emit-wrap (emit-value exp)))]
   [(p (list exp1 exp2))
    (emit-wrap
     (emit-value exp1)
     (case p
       [(+ - * < <= > >=) (display #\space) (display p) (display #\space)]
       [(=) (display " == ")]
       [(%>>) (display " >> ")]
       [(%<<) (display " << ")]
       [(%/) (display " / ")]
       [(binary-and) (display " & ")]
       [(binary-or)  (display " | ")]
       [(binary-xor) (display " ^ ")]
       [else (error 'backend-c-emit-op)])
     (emit-value exp2))]
   [(other wise) (error 'backend-c/generate-c/emit-op "unmatched value")]))



;;(: emit-primitive-value (->  Void))
(define (emit-primitive-value p exp*) (error 'emit-primitive-value-undefined))
(define (emit-primitive-pred p e1 e2) (error 'emit-primitive-pred-undefined))

(: emit-function-call (-> D2-Value D2-Value* Void))
(define (emit-function-call val val*)
  (emit-wrap
   (emit-cast->fn val val*)
   (sequence emit-value val* display "(" "" "," "" ")")))

;; primitives for generating syntax
(define-syntax-rule (emit-wrap a ...)
   (begin (display "(") a ... (display ")")))

(: display-seq (-> (Listof Any) Any Any Any Any Any Void))
(define (display-seq seq start before between after finish)
  (sequence display seq display start before between after finish))

(: sequence (All (A B) (-> (-> A Void) (Listof A) (-> B Void) B B B B B Void)))
(define (sequence f seq g start before between after finish)
  (: loop (All (A) (-> (-> A Void) (Listof A) Void)))
  (define (loop f seq)
    (if (null? seq)
        (g finish)
        (let ([seq^ (cdr seq)])
          (if (null? seq^)
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g finish))
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g between)
                     (loop f seq^))))))
  (g start)
  (loop f seq))

;; common c syntax constructs
(define-syntax-rule (emit-begin stm* exp)
  (emit-wrap
   (sequence emit-effect stm* display "" "" "" ", " "")
   exp))

(define-syntax-rule (emit-ternary a b c)
  (emit-wrap a (display " ? ") b (display " : ") c))


;; C Style casts
(define-syntax-rule (emit-cast->string exp)
  (emit-wrap (display "(const char*) ") exp))

(define-syntax-rule (emit-imdt-cast) (error 'emit-imdt-cast))

(: emit-cast->fn (-> D2-Value D2-Value* Void))
(define (emit-cast->fn exp args)
   (emit-wrap
    (emit-wrap
     (display IMDT-C-TYPE)
     (display " (*)")
     (let ([a* : (Listof String) (map (lambda (a) IMDT-C-TYPE) args)])
       (display-seq a* "(" "" "," "" ")")))
    (emit-value exp)))
