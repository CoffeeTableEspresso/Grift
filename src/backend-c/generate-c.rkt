#lang typed/racket
#|------------------------------------------------------------------------------+
|pass: src/generate-c
+-------------------------------------------------------------------------------+
|Author: Andre Kuhlenshmidt (akuhlens@indiana.edu)                              |
+-------------------------------------------------------------------------------+
| Description:
+-------------------------------------------------------------------------------+
| Grammer:
+------------------------------------------------------------------------------|#
;; The define-pass syntax
(require "../helpers.rkt"
         "../errors.rkt"
         "../configuration.rkt"
         "../language/data5.rkt"
         "../macros.rkt")


;; Only the pass is provided by this module
(provide generate-c)

(: IMDT-C-TYPE String)
(define IMDT-C-TYPE "long")

(: C-EXIT String)
(define C-EXIT "exit(-1)")

(: C-INCLUDES (Listof String))
(define C-INCLUDES '("stdio.h" "stdlib.h" "sys/time.h"))


(: generate-c (-> Data5-Lang Config Void))
(define (generate-c prgm config)
  (match-let ([(Prog (list name count type) (Labels lbl* exp)) prgm])
     (call-with-output-file (Config-c-path config) #:exists 'replace #:mode 'text
      (lambda ([p : Output-Port])
       (parameterize ([current-output-port p])
        (emit-program name type lbl* exp))))))

(: emit-program (-> String Schml-Type D5-Bnd-Code* D5-Body Void))
(define (emit-program name type code* body)
  (emit-source-comment name type)
  (emit-boiler-plate)
  (emit-declarations code*)
  (emit-main body)
  (emit-subroutines code*))

(define timer-boiler-plate
  (concat-string-literal
   "//This is the global state for the timer\n"
   "struct timeval timer_start_time;\n"
   "struct timeval timer_stop_time;\n"
   "struct timeval timer_result_time;\n"
   "int timer_started = 1;\n"
   "int timer_stopped = 1;\n\n"
   "void timer_report(){\n\n"
   "    // some very minor error checking\n"
   "    if(timer_started){\n"
   "        printf(\"error starting timer\");\n"
   "        exit(-1);\n"
   "    }\n"
   "    if(timer_stopped){\n"
   "        printf(\"error stopping timer\");\n"
   "        exit(-1);\n"
   "    }\n\n"
   "double t1 = timer_start_time.tv_sec + (timer_start_time.tv_usec / 1000000.0);\n"
   "double t2 = timer_stop_time.tv_sec + (timer_stop_time.tv_usec / 1000000.0);\n"
   "printf(\"time (sec): %lf\\n\", t2 - t1);\n"
   "}\n"
   #;(
   "    // subtract the two times in order to get result \n"
   "    timersub(&timer_stop_time, &timer_start_time, &timer_result_time);\n\n"
   "    // print out the result \n"
   "    printf(\"time (sec): %f\\n\", ((double) timer_result_time.tv_sec) +\n"
   "            (((double) timer_result_time.tv_usec) / 1000000.0));\n"
   "}\n")))


(define (emit-source-comment name type)
  (printf "// ~a should return ~a generated by the schml compiler.\n" name type))

(: emit-boiler-plate (-> Void))
(define (emit-boiler-plate)
  (display "\n//This is the boiler plate\n")
  (for ([i : String C-INCLUDES])
    (display "#include <") (display i) (display ">\n"))
  (newline)
  (display "void* alloc_ptr;\n")
  (newline)
  (display timer-boiler-plate)
  (newline))

(: emit-declarations (-> D5-Bnd-Code* Void))
(define (emit-declarations code*)
  (display "\n//These are the declarations\n")
  (for : Void ([bnd : D5-Bnd-Code code*])
    (match-let ([(cons lbl (Code var* exp)) bnd])
      (emit-function-prototype IMDT-C-TYPE (uid->string lbl) (map uid->string var*))
      (display ";\n"))))

(: emit-main (-> D5-Body Void))
(define (emit-main b)
  (display "\n//Obviously this is the main function\n")
  (emit-function "int" "main" '() b))

(: emit-subroutines (-> D5-Bnd-Code* Void))
(define (emit-subroutines code*)
    (display "\n//Here are all the definitions for Subroutines\n")
  (for : Void ([bnd : D5-Bnd-Code code*])
   (match-let ([(cons lbl (Code var* body)) bnd])
     (emit-function IMDT-C-TYPE (uid->string lbl) var* body))))

(: emit-function-prototype (-> String String (Listof String) Void))
(define (emit-function-prototype returns name vars)
  (display returns)
  (display #\space)
  (display name)
  (display-seq vars "( " (string-append IMDT-C-TYPE " ") "," " " ")"))

(: emit-function (-> String String Uid* D5-Body Void))
(define (emit-function returns name args body)
  (match-let ([(Locals local-var* tail) body])
    (emit-function-prototype returns name (map uid->string args))
    (emit-block local-var* tail)
    (newline)
    (newline)))

(: emit-block (-> Uid* D5-Tail Void))
(define (emit-block local-var* tail)
  (let ([local-var* (map uid->string local-var*)])
    (display "{\n")
    (display-seq local-var* "" (string-append IMDT-C-TYPE " ") "" ";\n" "")
    (emit-tail tail)
    (display "}")))

(: emit-tail (-> D5-Tail Void))
(define (emit-tail tail)
  (logging emit-tail (Vomit) tail)
  (match tail
    [(Begin s* t)
     (begin (for ([s : D5-Effect s*])
              (emit-effect s)
              (display ";\n"))
            (emit-tail t))]
    [(If t c a)
     (begin (display "if ")
            (emit-pred t)
            (emit-block '() c)
            (display " else ")
            (emit-block '() a)
            (newline))]
    [(Return e)
     (begin (display "return ")
            (emit-value e)
            (display ";\n"))]))

(: emit-pred (-> D5-Pred Void))
(define (emit-pred r)
  (match r
    #;[(If t c a) (emit-ternary (emit-pred t) (emit-pred c) (emit-pred a))]
    #;[(Begin stm* pred) (emit-begin stm* (emit-pred pred))]
    #;[(App v v*) (emit-function-call v v*)]
    [(Relop p e1 e2) (emit-op p (list e1 e2))]))

(: emit-value (-> D5-Value Void))
(define (emit-value e)
  (match e
    [(If t c a)       (emit-ternary (emit-pred t) (emit-value c) (emit-value a))]
    #;[(Begin stm* exp) (emit-begin stm* (emit-value exp))]
    [(App v v*)       (emit-function-call v v*)]
    [(Op p exp*)      (emit-op p exp*)]
    [(Var i)          (display (uid->string i))]
    [(Quote k)        (print k)]
    [(Halt)           (display "C-EXIT")]
    [(Code-Label i)  (begin
                       (display "((")
                       (display "long)")
                       (display (uid->string i))
                       (display ")"))]
    [other   (error 'generate-c-emit-value-match)]))



(: emit-effect (-> D5-Effect Void))
(define (emit-effect s)
  (match s
    [(If t (Begin c _) (Begin a _))
     (begin (display "if")
            (emit-pred t)
            (display "{")
            (emit-begin c (void))
            (display "} else {")
            (emit-begin a (void))
            (display "}")
            (newline))]
    [(Repeat i st sp (Begin e* _))
     (begin (display "for(")
            (display (uid->string i))
            (display " = ")
            (emit-value st)
            (display " ; ")
            (display (uid->string i))
            (display " < ")
            (emit-value sp)
            (display " ; ")
            (display (uid->string i))
            (display " += 1 ) {\n")
            (emit-begin e* (display "__asm__(\"\");"))
            (display "}\n"))]
    [(Op p exp*)
     (emit-op p exp*)]
    [(Assign uid exp)
     (begin (display (uid->string uid))
            (display " = ")
            (emit-value exp))]
    [(No-Op) (display " 0 ")]))

(: emit-op (-> Symbol D5-Value* Void))
(define (emit-op p exp*)
  (match* (p exp*)
   ;;[('Exit '()) (display C-EXIT)]
   [('Array-set! (list a o v)) (begin
                                 (emit-wrap (display "(long*)")
                                       (emit-value a))
                                 (display "[")
                                 (emit-value o)
                                 (display "] = ")
                                 (emit-value v))]
   [('Array-ref (list a o)) (begin
                                 (emit-wrap (display "(long*)")
                                            (emit-value a))
                                 (display "[")
                                 (emit-value o)
                                 (display "]"))]
   [('Printf (cons fmt exp*)) (begin (display "printf")
                                     (emit-wrap
                                      (emit-value fmt)
                                      (unless (null? exp*)
                                        (display ", ")
                                        (sequence emit-value exp* display "" "(void *)" "," "" ""))))]
   [('Print (list exp)) (begin (display "puts") (emit-wrap (emit-cast->string (emit-value exp))))]
   [('Alloc (list exp)) (begin (display "(long) (posix_memalign(&alloc_ptr, 8, 8 * ")
                               (emit-value exp)
                               (display "), alloc_ptr)"))]
   [('Exit (list exp)) (begin (display "exit") (emit-wrap (emit-value exp)))]
   [('timer-start (list))
    (display "timer_started = gettimeofday(&timer_start_time, NULL)")]
   [('timer-stop  (list))
    (display "timer_stopped = gettimeofday(&timer_stop_time, NULL)")]
   [('timer-report (list))
    (display "timer_report()")]
   [(p (list exp1 exp2))
    (emit-wrap
     (emit-value exp1)
     (case p
       [(+ - * < <= > >=) (display #\space) (display p) (display #\space)]
       [(=) (display " == ")]
       [(%>>) (display " >> ")]
       [(%<<) (display " << ")]
       [(%/) (display " / ")]
       [(binary-and) (display " & ")]
       [(binary-or)  (display " | ")]
       [(binary-xor) (display " ^ ")]
       [else (error 'backend-c-emit-op)])
     (emit-value exp2))]
   [(other wise) (error 'backend-c/generate-c/emit-op "unmatched value")]))



;;(: emit-primitive-value (->  Void))
(define (emit-primitive-value p exp*) (error 'emit-primitive-value-undefined))
(define (emit-primitive-pred p e1 e2) (error 'emit-primitive-pred-undefined))

(: emit-function-call (-> D5-Value D5-Value* Void))
(define (emit-function-call val val*)
  (emit-wrap
   (emit-cast->fn val val*)
   (sequence emit-value val* display "(" "" "," "" ")")))

;; primitives for generating syntax
(define-syntax-rule (emit-wrap a ...)
   (begin (display "(") a ... (display ")")))

(: display-seq (-> (Listof Any) Any Any Any Any Any Void))
(define (display-seq seq start before between after finish)
  (sequence display seq display start before between after finish))

(: sequence (All (A B) (-> (-> A Void) (Listof A) (-> B Void) B B B B B Void)))
(define (sequence f seq g start before between after finish)
  (: loop (All (A) (-> (-> A Void) (Listof A) Void)))
  (define (loop f seq)
    (if (null? seq)
        (g finish)
        (let ([seq^ (cdr seq)])
          (if (null? seq^)
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g finish))
              (begin (g before)
                     (f (car seq))
                     (g after)
                     (g between)
                     (loop f seq^))))))
  (g start)
  (loop f seq))

;; common c syntax constructs
(define-syntax-rule (emit-begin s* emit-res)
  (begin
    (for ([s : D5-Effect s*])
      (emit-effect s)
      (display ";\n"))
    emit-res))

(define-syntax-rule (emit-ternary a b c)
  (emit-wrap a (display " ? ") b (display " : ") c))


;; C Style casts
(define-syntax-rule (emit-cast->string exp)
  (emit-wrap (display "(const char*) ") exp))

(define-syntax-rule (emit-imdt-cast) (error 'emit-imdt-cast))

(: emit-cast->fn (-> D5-Value D5-Value* Void))
(define (emit-cast->fn exp args)
   (emit-wrap
    (emit-wrap
     (display IMDT-C-TYPE)
     (display " (*)")
     (let ([a* : (Listof String) (map (lambda (a) IMDT-C-TYPE) args)])
       (display-seq a* "(" "" "," "" ")")))
    (emit-value exp)))
