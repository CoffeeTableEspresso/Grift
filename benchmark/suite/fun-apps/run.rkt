#lang racket

(require
 "../../../src/compile.rkt"
 racket/date
 math/statistics)

;; This is the script for running the casted-X-n-function-application
;; benchmark.
;; TODO Setup command line argument that saftly cleans up tmp files.


#|--------------------------------------------------------------------
Configuaration variables
|#

;; Iterations = the number of times the action in question is repeated
;; in order to make it large enough to measure acurately
(define iterations 10000)

;; Runs = the number of times the test is repeated in order to understand
;; how much volitility is coming from the system it is being run on
(define runs 30)

;; casts is a list of the number of casts to test in the benchmark
(define casts (build-list 11 values))

;; The file is hard coded for each compiler configuration because
;; it makes formatting the each new data file easier.

#|-------------------------------------------------------------------
lightweight benchmark description

The following bit of code almost completely describes this benchmark.
In the benchmark a function is casted some number of times and
we time a single application of the resulting function value.
This test code can be compiled with diffent compiler configurations
to test the efficiency of applying a casted function.
|#

(define (generate-source output-port iterations casts)
  (pretty-print
   `(letrec ([cast-loop
              : (Int (Int -> Int) -> (Int -> Int))
              (lambda ([n : Int] [g : (Int -> Int)])
                (if (= n 0)
                    g 
                    (cast-loop (- n 1) (: g (Dyn -> Dyn)))))])
      (let ([f : (Int -> Int) (lambda ([x : Int]) x)])
        (let ([f^ : (Int -> Int) (cast-loop ,casts f)])
          (begin
            (timer-start)
            (repeat (i 0 ,iterations ) (f^ 0))
            (timer-stop)
            (timer-report)))))
   output-port 1))

#|-------------------------------------------------------------------
Directory Structure

This file always attempts to find this directory before running
any parts that will create any files.
As such it will only work from the command line.
Repls such as the repl found in emacs's racket mode cannot run
this file because they alter the 'run-file system-path making
it hard to find this directory.
|#

(define this-dir
 (path-only (path->complete-path (find-system-path 'run-file))))

;; This check is a first attempt at providing some protection from
;; this script which can create many files.
(unless (file-exists? (build-path this-dir "run.rkt"))
  (error 'run.rkt "may not work in a repl"))

;; The source directory is where the generated GTLC files will
;; be deposited
(define src-dir (build-path this-dir "src/"))
(unless (directory-exists? src-dir)
  (make-directory src-dir))

;; The temp directory is used to save copies of the C and ASM files
;; that are generated by the Schml Compiler
(define tmp-dir (build-path this-dir "tmp/"))
(unless (directory-exists? tmp-dir)
  (make-directory tmp-dir))

;; This is where the final executable benchmarks are stored
(define exe-dir (build-path this-dir "exe/"))
(unless (directory-exists? exe-dir)
  (make-directory exe-dir))

;; This is where the data is stored for each run of the benchmark
(define logs-dir (build-path this-dir "logs/"))
(unless (directory-exists? logs-dir)
  (make-directory logs-dir))

;; This is where the pdf graphs are stored
(define pdf-dir (build-path this-dir "pdfs/"))
(unless (directory-exists? pdf-dir)
  (make-directory pdf-dir))


;; The data files are "Uniquified" by the current hash of the git repo
;; and the date. The hope is that this makes keeping track of the
;; progression of the compiler and the git commit to find that commit
;; easier
(define unique-name
  (let ([date (parameterize ([date-display-format 'iso-8601])
                (date->string (current-date)))]
        [hash (parameterize ([current-output-port (open-output-string)])
                (or (and (system "git rev-parse --short HEAD")
                         (let ((s (get-output-string (current-output-port))))
                           ;; get rid of a trailing newline
                           (substring s 0 (- (string-length s) 1))))
                    "no_hash"))])
    (format "~a-~a-fn-app" date hash)))

(define data-file (build-path logs-dir (string-append unique-name ".dat")))

#|-------------------------------------------------------------------
Generating the source code to benchmark

This line generates the source files and creates the list benchmarks
that records the pertinent configuration of the source files which is
the base file name, the path to the file, and the number of casts.
|#
(display "Generating benchmark source code\n")

(define benchmarks
  (for*/list ([cast (in-list casts)])
    (let* ([base (format "app-test_i-~a_c-~a" iterations cast)]
           [src  (build-path src-dir (string-append base ".schml"))]
           [port (open-output-file src #:exists 'replace)])
      (printf "\t~a\n" base)
      (generate-source port iterations cast)
      (close-output-port port)
      (list base src cast))))

(call-with-output-file
  (build-path this-dir "fn-app-code-template.schml") #:exists 'replace
  (lambda (p) (generate-source p 'N-ITERATIONS 'N-CASTS)))

;; Run each benchmark for a particular compiler configuration
(define (run-series out cast-rep)
  (define spec #px"^time \\(sec\\): (\\d+.\\d+)\nUnit : \\(\\)\n$")
  (for* ([b (in-list benchmarks)])
    (match-let ([(list base src casts) b])
      (let* ([base^ (format "~a_~a" base cast-rep)] 
             [tmpc (build-path tmp-dir (string-append base^ ".c"))]
             [tmpa (build-path tmp-dir (string-append base^ ".s"))]
             [exe  (build-path exe-dir  (string-append base^ ".out"))])
        ;; Compile the src file using the schml library
        (compile src #:output exe #:keep-c tmpc #:keep-a tmpa
                 #:cast-rep cast-rep #:cc-opt "-w" #:mem (* 4096 100))
        ;; Give a little feedback so that running tests isn't so boring
        (printf "\t~a\n" base^)
        ;; run each test enough to establish the std-dev
        (let* ([run-results
                (for/list ([run (in-range runs)])
                  (let* ([result
                          ;; result is the io output of the program
                          (with-output-to-string
                            (lambda () (system (path->string exe))))]
                         ;; Regular expression for the expected output
                         
                   ;; parse? = `(,entire-output . ,float-string) or #f
                   [parse? (regexp-match spec result)])
                    (unless parse?
                      (error 'benchmark/fun-app
                             "failed to parse output of ~a\n\t~a\n"
                             exe result))
                    ;; parse the number
                    (string->number (cadr parse?))))]
               [mean (mean run-results)]
               [sdev (stddev run-results)])
          (fprintf out "~a\t~a\t~a\n" casts mean sdev))))))

;; Here we gather and write the benchmark data to file
(call-with-output-file data-file #:exists 'replace
  (lambda (data-out)
    (display "running benchmarks\n")
    ;; For documentation sake this bit emits a gnuplot compatable comment
    ;; that decribes the benchmark that generated the output data
    (fprintf data-out "# casted function application benchmark data\n")
    (fprintf data-out "# The current settings are\n")
    (fprintf data-out "# RUNS = ~a\n" runs)
    (fprintf data-out "# ITERATIONS = ~a\n" iterations)
    (fprintf data-out "# CASTS = ~a\n" casts)
    (fprintf data-out "# GTLC source code template:\n")
    ;; here generate source is writing to a temp buffer so that we
    ;; can comment out the code.
    (let-values ([(in out) (make-pipe)])
      (generate-source out 'ITERATIONS 'CASTS)
      ;; Sends eof
      (close-output-port out)
      (for ([line (in-lines in)])
        (display (string-append "#" line "\n") data-out)))
    (display "# data points = num-of-casts mean-time-secs stddev-time\n"
             data-out)
    ;; Run the twosome compiler configuration over each benchmark
    (run-series data-out 'Twosomes)
    ;; Two newlines to start a new series
    (display "\n\n" data-out)
    ;; Run the coercion compiler configuration over each benchmark 
    (run-series data-out 'Coercions)))

(when (system "which gnuplot")
  (define data (path->string data-file))
  (define make-pdf  (path->string (build-path this-dir "pdf.gnuplot")))
  (define show-plot (path->string (build-path this-dir "show.gnuplot")))
  (define pdf-file
    (path->string (build-path pdf-dir (string-append unique-name ".pdf"))))
  (system (format "gnuplot -e \"inFile='~a';outFile='~a'\" ~a"
                  data pdf-file make-pdf))
  (system (format "gnuplot -e \"inFile='~a'\" ~a" data show-plot)))
