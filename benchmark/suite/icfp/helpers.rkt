#lang racket
(require racket/date
         math/statistics
         "../../../src/compile.rkt")
(provide (all-defined-out))
#|-------------------------------------------------------------------
Directory Structure

This file always attempts to find this directory before running
any parts that will create any files.
As such it will only work from the command line.
Repls such as the repl found in emacs's racket mode cannot run
this file because they alter the 'run-file system-path making
it hard to find this directory.
|#

(define run-file-dir
 (path-only (path->complete-path (find-system-path 'run-file))))

;; The source directory is where the generated GTLC files will
;; be deposited
(define src-dir (build-path run-file-dir "src/"))

;; The temp directory is used to save copies of the C and ASM files
;; that are generated by the Schml Compiler
(define tmp-dir (build-path run-file-dir "tmp/"))

;; This is where the final executable benchmarks are stored
(define exe-dir (build-path run-file-dir "exe/"))

;; This is where the data is stored for each run of the benchmark
(define logs-dir (build-path run-file-dir "logs/"))

;; This is where the pdf graphs are stored
(define pdf-dir (build-path run-file-dir "pdfs/"))

;; The data files are "Uniquified" by the current hash of the git repo
;; and the date. The hope is that this makes keeping track of the
;; progression of the compiler and the git commit to find that commit
;; easier
(define unique-name
  (let ([date (parameterize ([date-display-format 'iso-8601])
                (date->string (current-date)))]
        [hash (parameterize ([current-output-port (open-output-string)])
                (or (and (system "git rev-parse --short HEAD")
                         (let ((s (get-output-string (current-output-port))))
                           ;; get rid of a trailing newline
                           (substring s 0 (- (string-length s) 1))))
                    "no_hash"))])
    (format "~a-~a-fn-cast" date hash)))

(define data-file (build-path logs-dir (string-append unique-name ".dat")))

(define (initialize-dirs! name)
  ;; This check is a first attempt at providing some protection from
  ;; this script which can create many files.
  (unless (file-exists? (build-path run-file-dir name))
    (error 'run.rkt "may not work in a repl"))
  (unless (directory-exists? src-dir)
    (make-directory src-dir))
  (unless (directory-exists? tmp-dir)
    (make-directory tmp-dir))
  (unless (directory-exists? exe-dir)
    (make-directory exe-dir))
  (unless (directory-exists? logs-dir)
    (make-directory logs-dir))
  (unless (directory-exists? pdf-dir)
    (make-directory pdf-dir)))


#| SI Unit Conversions |#
(define (unit->micro x) (* x (expt 10 6)))
(define (unit->pico x) (* x (expt 10 12)))


;; Helpers for writing, compiling and running programs
(define (compile&run/iteration-time #:base-name     name
                                    #:src-file      src-file
                                    #:runs          runs
                                    #:iterations    iters 
                                    #:cast-repr     c-rep
                                    #:function-repr f-rep
                                    #:output-regexp out-rx
                                    #:memory-limit  [mem (* 4096 2000)])

  ;; Compile the source code keeping both .c and .s files
  (define c-file   (build-path tmp-dir (string-append name ".c")))
  (define s-file   (build-path tmp-dir (string-append name ".s")))
  (define exe-file (build-path exe-dir (string-append name ".out")))
  (compile src-file
           #:output exe-file
           #:keep-c c-file
           #:keep-a s-file
           #:cast-rep c-rep
           #:cc-opt "-w -O3"
           #:mem mem)
  
  ;; Run the test "runs" number of times and save the results
  ;; as a list of micro-second numbers.
  (define run-results
    (for/list ([a-run (in-range 0 runs)])
      (define result (with-output-to-string
                       (lambda ()
                         (with-input-from-string (format "~a" iters)
                           (lambda ()
                              (system (path->string exe-file)))))))
      ;; Regular expression for the expected output
      ;; parse? = `(,entire-output . ,float-string) or #f
      (define parse? (regexp-match out-rx result))
      (unless parse?
        (error 'benchmark/fun-app
               "failed to parse output of ~a\n\t~a\n"
               exe-file result))
      (define parsed-time? (string->number (cadr parse?)))
      (unless parsed-time?
        (error 'benchmark/fun-app
               "failed to parse numeric output of ~a\n\t~a\n"
               exe-file result))
      (/ (unit->micro parsed-time?) iters)))
  
  ;; Return a pair containting mean and std-deviation
  (list (mean run-results) (stddev run-results)))

;; Save the source code ./src/name.schml
(define (write-source name prog)
  (define src-file (build-path src-dir (string-append name ".schml")))
  (call-with-output-file src-file #:exists 'replace #:mode 'text
    (lambda (file-port)
      (define print-without-quote 1)
      (pretty-print prog file-port print-without-quote)))
  src-file)
