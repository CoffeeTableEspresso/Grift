#lang racket
(require racket/date
         math/statistics
         "../../../src/compile.rkt"
         "../../../src/schml/syntax-to-schml0.rkt"
         "../../../src/casts/casts-to-coercions.rkt"
         "../../../src/language/forms.rkt"
         "../../../src/backend-c/code-generator.rkt")
(provide (all-defined-out))
#|-------------------------------------------------------------------
Directory Structure

This file always attempts to find this directory before running
any parts that will create any files.
As such it will only work from the command line.
Repls such as the repl found in emacs's racket mode cannot run
this file because they alter the 'run-file system-path making
it hard to find this directory.
|#

(define run-file-dir
 (path-only (path->complete-path (find-system-path 'run-file))))

;; The source directory is where the generated GTLC files will
;; be deposited
(define src-dir (build-path run-file-dir "src/"))

;; The temp directory is used to save copies of the C and ASM files
;; that are generated by the Schml Compiler
(define tmp-dir (build-path run-file-dir "tmp/"))

;; This is where the final executable benchmarks are stored
(define exe-dir (build-path run-file-dir "exe/"))

;; This is where the data is stored for each run of the benchmark
(define logs-dir (build-path run-file-dir "logs/"))

;; This is where the pdf graphs are stored
(define pdf-dir (build-path run-file-dir "pdfs/"))

;; The data files are "Uniquified" by the current hash of the git repo
;; and the date. The hope is that this makes keeping track of the
;; progression of the compiler and the git commit to find that commit
;; easier
(define unique-name
  (let ([date (parameterize ([date-display-format 'iso-8601])
                (date->string (current-date)))]
        [hash (parameterize ([current-output-port (open-output-string)])
                (or (and (system "git rev-parse --short HEAD")
                         (let ((s (get-output-string (current-output-port))))
                           ;; get rid of a trailing newline
                           (substring s 0 (- (string-length s) 1))))
                    "no_hash"))])
    (format "~a-~a-fn-cast" date hash)))

(define data-file (build-path logs-dir (string-append unique-name ".dat")))

(define (initialize-dirs! name)
  ;; This check is a first attempt at providing some protection from
  ;; this script which can create many files.
  (unless (file-exists? (build-path run-file-dir name))
    (error 'run.rkt "may not work in a repl"))
  (unless (directory-exists? src-dir)
    (make-directory src-dir))
  (unless (directory-exists? tmp-dir)
    (make-directory tmp-dir))
  (unless (directory-exists? exe-dir)
    (make-directory exe-dir))
  (unless (directory-exists? logs-dir)
    (make-directory logs-dir))
  (unless (directory-exists? pdf-dir)
    (make-directory pdf-dir)))


#| SI Unit Conversions |#
(define (unit->micro x) (* x (expt 10 6)))
(define (unit->nano x) (* x (expt 10 9)))
(define (unit->pico x) (* x (expt 10 12)))


;; Helpers for writing, compiling and running programs
(define (compile&run/iteration-time #:base-name     name
                                    #:src-file      src-file
                                    #:runs          runs
                                    #:iterations    iters 
                                    #:cast-repr     c-rep
                                    #:function-repr f-rep
                                    #:output-regexp out-rx
                                    #:unit-conversion [unit-> unit->nano]
                                    #:memory-limit  [mem (* 4096 2000)]
                                    #:mean-of-runs? [mean-of-runs? #t])

  ;; Compile the source code keeping both .c and .s files
  (define c-file   (build-path tmp-dir (string-append name ".c")))
  (define s-file   (build-path tmp-dir (string-append name ".s")))
  (define exe-file (build-path exe-dir (string-append name ".out")))

  (printf "compiling ~a\n" (path->string (find-relative-path run-file-dir src-file)))
  (time
   (compile src-file
           #:output exe-file
           #:keep-c c-file
           #:keep-a s-file
           #:cast-rep c-rep
           #:cc-opt "-w -O3"
           #:mem mem))
  (define-values (run-result* iter-result*)
    (run-test-repeatedly exe-file runs iters out-rx #:unit-conversion unit->))
  (if mean-of-runs?
      (mean-of-runs run-result* iter-result*)
      (list run-result* iter-result*)))

(define (compile-c/run #:base-name name
                       #:src-file  src-file
                       #:runs      runs
                       #:iters     iters
                       #:out-rx    out-rx
                       #:unit-conversion [unit-> unit->nano]
                       #:mean-of-runs? [mean-of-runs? #t])
  (define tmp-s (build-path tmp-dir (string-append name ".s")))
  (define exe-file (build-path exe-dir (string-append name ".out")))
  (cc/runtime (path->string exe-file)
              (path->string src-file)
              "-w -O3")
  (define-values (run-result* iter-result*)
    (run-test-repeatedly exe-file runs iters out-rx #:unit-conversion unit->))

  (if mean-of-runs?
      (mean-of-runs run-result* iter-result*)
      (list run-result* iter-result*)))

(define (mean-of-runs run-result* iter-result*)
  (define-values (run-mean run-sdev iter-mean iter-sdev)
    (values (mean run-result*)
            (stddev run-result*)
            (mean iter-result*)
            (stddev iter-result*)))
  (printf "\n\truns: m= ~a s= ~a\n\titer: m= ~a s= ~a\n"
          (real->decimal-string run-mean  10)
          (real->decimal-string run-sdev  10)
          (real->decimal-string iter-mean 10)
          (real->decimal-string iter-sdev 10))
  ;; Return a pair containting mean and std-deviation
  (list iter-mean iter-sdev))

;; Produces a two values a list of time per run and a list of time per iteration
;; both results are in terms of whatever unit is specified.
(define (run-test-repeatedly exe-file runs iters out-rx
                             #:unit-conversion [unit->? unit->nano]
                             #:epsilon-check   [epsilon (expt 10 -6)])
  
  ;; Run the test "runs" number of times and save the results
  ;; as a list of micro-second numbers.
  (for/lists (r i)
             ([a-run (in-range 0 runs)])
    (when (= (modulo a-run 10) 0)
      (display #\. (current-error-port))
      (flush-output (current-error-port))) 
    (define result (with-output-to-string
                     (lambda ()
                       (with-input-from-string (format "~a" iters)
                         (lambda ()
                           (system (path->string exe-file)))))))
    ;; Regular expression for the expected output
    ;; parse? = `(,entire-output . ,float-string) or #f
    (define parse? (regexp-match out-rx result))
    (unless parse?
      (error 'benchmark/fun-app
             "failed to parse output of ~a\n\t~a\n"
             exe-file result))
    (define parsed-time? (string->number (cadr parse?)))
    (unless parsed-time?
      (error 'benchmark/fun-app
             "failed to parse numeric output of ~a\n\t~a\n"
             exe-file result))
    (unless (> parsed-time? epsilon)
      (error 'benchmark/fun-app
             "loop time not large enough for significance: ~a from ~a"
             parsed-time? exe-file))
    (define converted-time (unit->? parsed-time?))
    (values converted-time (/ converted-time iters))))

;; Save the source code ./src/name.schml
(define (write-source name prog)
  (define src-file (build-path src-dir (string-append name ".schml")))
  (call-with-output-file src-file #:exists 'replace #:mode 'text
    (lambda (file-port)
      (define print-without-quote 1)
      (pretty-print prog file-port print-without-quote)))
  src-file)

(define (make-timing-loop
         #:letrec-bnds    [letrec-bnds '()]
         #:let-bnds       [let-bnds '()]
         #:acc-type       acc-type
         #:acc-init       acc-init
         #:use-acc-action use-acc-action ; (Symbol -> Schml-Expr)
         #:timed-action   timed-action)   ; (Symbol Symbol -> Schml-Expr)
  `(letrec ,letrec-bnds 
     (let ([iters : Int (read-int)]
           [acc   : (GRef ,acc-type) (gbox ,acc-init)]
           ,@let-bnds)
       (letrec ([run-test
                 : (Int ,acc-type -> ,acc-type)
                 (lambda ([i : Int] [acc : ,acc-type])
                   ,(timed-action 'i 'acc))])
         (begin
           (timer-start)
           (repeat (i 0 iters)
                   (gbox-set! acc (run-test i (gunbox acc))))
           (timer-stop)
           (timer-report)
           ,(use-acc-action '(gunbox acc)))))))

(define timing-loop-example
  (make-timing-loop
   #:letrec-bnds '(FUNC-BND ...)
   #:let-bnds    '(DATA-BND ...)
   #:acc-type    'TYPE-OF-ACCUMULATOR
   #:acc-init    'ACCUMULATOR-INIT
   #:timed-action   (lambda (i acc) 'TIMED-CODE)
   #:use-acc-action (lambda (acc) 'USE-OF-ACCUMULATOR)))

(define (sizeof-type t)
  (match t
    [`(,t* ... -> ,t)
     (+ (for/sum ([t t*]) (sizeof-type t))
        (sizeof-type t)
        1)]
    [(or `(GRef ,t) `(GVect ,t)) (+ 1 (sizeof-type t))]
    [(or (? symbol?) (? null?)) 1]))

(define (sizeof-type* t1 t2)
  (cond
    [(equal? t1 t2) 1]
    [else
     (match* (t1 t2)
       [(`(,t1* ... -> ,t1) `(,t2* ... -> ,t2))
        (+ (for/sum ([t1 t1*] [t2 t2*]) (sizeof-type* t1 t2))
           (sizeof-type* t1 t2)
           1)]
       [(`(GRef ,t1) `(GRef ,t2)) 
        (+ 1 (sizeof-type* t1 t2))]
       [(`(GVect ,t1) `(GVect ,t2))
        (+ 1 (sizeof-type* t1 t2))]
       [((or (? symbol?) (? null?)) _) 1]
       [(_ (or (? symbol?) (? null?))) 1])]))

(define (sizeof-coercion c)
  (match c
    [(Identity) 1]
    [(Project ty lbl) 1]
    [(Inject ty) 1]
    [(Sequence fst snd)
     (+ 1 (sizeof-coercion fst) (sizeof-coercion snd))]
    [(Failed label) 1]
    [(Fn arr args ret)
     (+ 1
        (for/sum ([c args]) (sizeof-coercion c))
        (sizeof-coercion ret))]
    [(Ref r w)
     (+ 1 (sizeof-coercion r) (sizeof-coercion w))]
    [else (error 'sizeof-coercion "unmatched ~a" c)]))

(define (sizeof-coercion-of-types t1 t2)
  (sizeof-coercion
   ((mk-coercion "")
    (parse-type (datum->syntax #'foo t1))
    (parse-type (datum->syntax #'foo t2)))))
